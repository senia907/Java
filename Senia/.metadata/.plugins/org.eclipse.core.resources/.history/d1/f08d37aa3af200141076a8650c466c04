package compression_algorithms;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.PriorityQueue;
import java.util.stream.Stream;
import algorithms.search.State;
/**
* The full Huffman Algorithm, one function for Compressing an InPutStream and sending it to an OutPutStream,
* the other one is for DeCompressing a compressed BitSet with a Dictionary.
* @author  Senia Kalma
* @since   4/5/2015
*/

public class HuffmanAlg extends CommonCompressor {

	@Override
	public OutputStream compress(InputStream in,OutputStream out) {
		String input;
		ObjectInputStream mIn = new ObjectInputStream(in);
		input = (String) mIn.readObject();
		HashMap<Character, Hchar> countAppearance=new HashMap<>();	//Counting each letter Appearances
		for(char c: input.toCharArray()){
			Hchar hc=countAppearance.get(c);
			if(hc==null){
				hc=new Hchar();
				hc.character=""+c;
				hc.count=0;
				countAppearance.put(c, hc);
			}
			hc.count++;
		}
		
		PriorityQueue<Hchar> pq=new PriorityQueue<Hchar>(	//Adds all the chars to a PQ by the compare func
		new Comparator<Hchar>() {
			public int compare(Hchar o1, Hchar o2) {
			return o1.count-o2.count;
			}
		});
		pq.addAll(countAppearance.values());
		
		while(pq.size()>1){		//Algorithms main loop - Building the tree
			Hchar hc0=pq.poll();
			Hchar hc1=pq.poll();
			Hchar hc2=new Hchar();
			hc2.count=hc0.count+hc1.count;
			hc2.character=hc0.character+hc1.character;
			hc2.left=hc0;
			hc2.right=hc1;
			pq.add(hc2);
		}
		DFSbinRep(pq.poll(),"");	//Call for recursive function - Adding "0" for left node and "1" for right
		
		ArrayList<CharNode> DicArr = new ArrayList<CharNode>();	//ArrayList holding CharNodes containing a char, its number of appearances and its string and bit reprasention.
		
		while(pq.peek()!=null){
			if(pq.peek().character.length()==1){
				CharNode CNode;
				CNode.ch=pq.peek().character.charAt(0);
				CNode.bitRep=String2BitSet(pq.peek().binRep);
				DicArr.add(CNode);
			}
		pq.poll();
		}
		
		ObjectOutputStream out2 = new ObjectOutputStream(out);
		out2.writeObject(DicArr);		//Writing the Dictionary
		
		// now working on converting the string to bits using the Dictionary we just made.
		String stringRep="";
		CharNode CNode;
		for(char c: input.toCharArray()){
			if(c!='\t' && c!='\r' && c!='\n'){
				System.out.println(this.count.get(c).binRep);
				//stringRep+=this.count.get(c).binRep;
				Iterator<CharNode> Citer = DicArr.iterator();
				while(Citer.hasNext()){
					CNode=Citer.next();
					if(CNode.ch==c){
						System.out.println(CNode.bitRep);
						stringRep+=CNode.bitRep;
					}
				}
			}
		}
		//We worked with string till here, yet it isn't efficient, so we will convert and send a BitSet
		BitSet bits = new BitSet();
		bits=String2BitSet(stringRep);		//Converting stringRep to a BitSet(Rep) - <2>
		ObjectOutputStream out3 = new ObjectOutputStream(out);
		out3.writeObject(bits);	//Writing the bits to the outputStream we got
		
		return out;
		
	}	//Compress close
	
	private BitSet String2BitSet(String string) {
		BitSet bits = new BitSet();
		bits.set((string.length()+1));	//LAST BIT=TRUE AS A PLACE HOLDER (!!!) - NOT PART OF THE ORIGINAL STRING
		for(int i=0;i<string.length();i++){
			if(string.substring(i, (i+1)) == "1"){
				bits.set(i, true);
			}
			bits.set(i, false);
		}
			
		return bits;
	}

	private void DFSbinRep(Hchar node,String bin) {	
		node.binRep+=bin;
		if(node.left!=null){
			DFSbinRep(node.left, node.binRep+"0");
		}
		if(node.right!=null){
			DFSbinRep(node.right, node.binRep+"1");
		}
	}
	
	
	/*private void DFSbinRep(Hchar node,BitSet bin,int index){			DFS WITH BITS(OLD)
		//node.binRep+=bin;
		node.bits.set(index, false);	//old Space-holder removes
		index=index+bin.length();
		index++;
		node.bits.set(index, true);		//new Space-holder
		BitSet shifted = new BitSet();
		for(int j=0;j < bin.length();j++){	//at the length of bin
			for(int i=0;i<index;i++){	//Moves(Shift) left
				if(node.bits.get(i)==true)
					shifted.set((i-1));
			}
		}
		node.bits=shifted;
		for(int i=0;i<bin.length();i++){	//puts the bin data in the right side of node.bits
			node.bits.set(i, bin.get(i));
		}
		if(node.left!=null){
			//DFSbinRep(node.left, node.binRep+"0");
			node.bits.set((index-1), false);
			DFSbinRep(node.left, node.bits,index);
		}
		if(node.right!=null){
			//DFSbinRep(node.right, node.binRep+"1");
			node.bits.set((index-1), true);
			DFSbinRep(node.left, node.bits ,index);
		}
	}*/

	@Override
	public OutputStream deCompress(InputStream in,OutputStream out) throws IOException, ClassNotFoundException {
		ArrayList<CharNode> DicArr;
		ObjectInputStream mIn = new ObjectInputStream(in);
		DicArr = (ArrayList<CharNode>) mIn.readObject();	//ArrayList holding CharNodes as the Dictionary
	    CharNode CNode;
	    Iterator<CharNode> iter = DicArr.iterator();
	    System.out.println("Our Huffman Dictionary is:");
	    while(iter.hasNext()){
	    	CNode = iter.next();
		    System.out.print("The char: "+CNode.ch+" is: ");
		    for(int j=0;j<(CNode.bitRep.length()-1);j++){	//the last bit=true as a placeholder, so we won't print it
		    	System.out.print(CNode.bitRep.get(j));
		    }
		    System.out.println(" in binary.");
	    }
		ObjectOutputStream out2 = new ObjectOutputStream(out);
		out2.writeObject(DicArr);		//Writing the Dictionary
		
	    ObjectInputStream in2 = new ObjectInputStream(in);
	    BitSet bits = new BitSet();		
	    bits = (BitSet) in2.readObject();
	    int ComIndex=0;		//Index of the already processed data.
	    String readString = null;
	    String deCom = null;	//Processed string(Chars..)
	    for(int i=0;i<(bits.length()-1);i++){	//Remember that the last bit=true as a place holder and its not a part of the "real" string
	    	if(bits.get(i)==true)
	    		readString+="1";
	    	else
	    		readString+="0";
	    	//if(ComIndex!=(bits.length()-1)){
	    		Iterator<CharNode> iter2 = DicArr.iterator();
	    		while(iter2.hasNext()){
	    			CNode=iter.next();
	    			if(CNode.bitRep==String2BitSet(readString).get(ComIndex, i)){
	    				deCom+=CNode.ch;
	    				ComIndex=i;
	    			}
	    		}
	    	//}
	    }
		//We worked with string till here, yet it isn't efficient, so we will convert and send a BitSet
		BitSet sendbits = new BitSet();
		sendbits=String2BitSet(deCom);		//Converting stringRep to a BitSet(Rep) - <2>
		ObjectOutputStream out3 = new ObjectOutputStream(out);
		out3.writeObject(sendbits);		//Writing the bits to the outputStream we got
	    
		return out;
	}

}
